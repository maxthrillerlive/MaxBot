/**
 * MaxBot Main Entry Point (Updated Version)
 * This version uses only the plugin manager system for commands
 */

require('dotenv').config();
const WebSocket = require('ws');
const fs = require('fs');
const path = require('path');
const logger = require('./logger');
const { spawn } = require('child_process');
const twitchAuth = require('./twitch-auth');
const PluginManager = require('./pluginManager');
const ConfigManager = require('./configManager');

// Define startTime
const startTime = Date.now();

// Initialize configuration manager
const configManager = new ConfigManager(logger);

// Initialize plugin manager with logger and config manager
const pluginManager = new PluginManager(logger, configManager);

// Get WebSocket port from config
const wsPort = configManager.get('webcp.wsPort', process.env.PORT || 8080);

// Declare WebSocket server variable in global scope
let wss;

// Add a helper function for consistent logging
function logInfo(message) {
    const time = new Date().toTimeString().substring(0, 8);
    console.log(`[${time}] \x1b[32minfo:\x1b[0m ${message}`);
}

// Move lock file to project root directory
const lockFile = path.join(__dirname, '..', 'bot.lock');
logInfo('Lock file location: ' + lockFile);

try {
    // Check if lock file exists and if the process is still running
    if (fs.existsSync(lockFile)) {
        const pid = fs.readFileSync(lockFile, 'utf8');
        logInfo('Found existing lock file with PID: ' + pid);
        try {
            // Try to send a signal to the process to see if it's running
            process.kill(parseInt(pid), 0);
            console.error('Error: Bot is already running (PID: ' + pid + ')');
            console.error('Lock file location:', lockFile);
            console.error('If you\'re sure no other instance is running, delete the bot.lock file and try again');
            process.exit(1);
        } catch (e) {
            // Process not found, safe to continue
            logInfo('Found stale lock file, removing...');
            fs.unlinkSync(lockFile);
        }
    }
    // Create lock file with current process ID
    fs.writeFileSync(lockFile, process.pid.toString());
    logInfo('Created lock file with PID: ' + process.pid);
    
    // Initialize WebSocket server here, after lock file check but before Twitch connection
    wss = new WebSocket.Server({ port: wsPort });
    logInfo(`WebSocket server starting on port ${wsPort}`);
    
    // WebSocket heartbeat implementation
    wss.on('connection', (ws) => {
        logInfo('Control panel connected');
        
        // Set up heartbeat for this connection
        ws.isAlive = true;
        ws.on('pong', () => {
            // Mark the connection as alive when pong is received
            ws.isAlive = true;
        });
        
        // Send initial status
        sendStatus(ws);
        
        // Set up a ping interval for this specific connection
        const pingInterval = setInterval(() => {
            if (ws.readyState === WebSocket.OPEN) {
                try {
                    // Send a ping frame (not a message)
                    ws.ping();
                } catch (error) {
                    console.error('Error sending ping:', error);
                    clearInterval(pingInterval);
                }
            } else {
                clearInterval(pingInterval);
            }
        }, 30000);
        
        // Set up a status update interval for this specific connection
        const statusInterval = setInterval(() => {
            if (ws.readyState === WebSocket.OPEN) {
                try {
                    sendStatus(ws);
                } catch (error) {
                    console.error('Error sending status update:', error);
                    clearInterval(statusInterval);
                }
            } else {
                clearInterval(statusInterval);
            }
        }, 5000);
        
        // Handle messages from the control panel
        ws.on('message', (data) => {
            try {
                const message = JSON.parse(data);
                logInfo(`Received message from control panel: ${message.type}`);
                
                // Handle different message types
                handleWebSocketMessage(ws, message);
            } catch (error) {
                console.error('Error handling WebSocket message:', error);
            }
        });
        
        // Handle connection close
        ws.on('close', () => {
            logInfo('Control panel disconnected');
            clearInterval(pingInterval);
            clearInterval(statusInterval);
        });
    });
    
    // Set up a ping interval for all connections
    setInterval(() => {
        wss.clients.forEach((ws) => {
            if (ws.isAlive === false) {
                logInfo('Terminating inactive connection');
                return ws.terminate();
            }
            
            ws.isAlive = false;
        });
    }, 60000);
} catch (error) {
    console.error('Error initializing server:', error);
    process.exit(1);
}

// Initialize Twitch connection and load plugins
twitchAuth.connectAndWaitForJoin()
    .then(clientObj => {
        const client = clientObj.client;
        logInfo('Successfully connected to Twitch');
        
        // Create the bot object to share with plugins
        const botObject = {
            client,
            pluginManager,
            logger,
            messageHandlers: []
        };
        
        // Set the bot instance for the plugin manager
        pluginManager.setBot(botObject);
        
        // Now load and initialize plugins
        pluginManager.loadPlugins();
        pluginManager.initPlugins();
        
        // Start periodic connection checking
        twitchAuth.startPeriodicConnectionCheck(60000); // Check every minute
        
        // Show the "safely stop" message after everything is loaded
        logInfo('\nTo safely stop the bot, press Ctrl+C');
    })
    .catch(err => {
        console.error('Connection failed:', err);
        if (err.message.includes('authentication failed')) {
            console.error('Please check your CLIENT_TOKEN in .env file and make sure it starts with "oauth:"');
            console.error('You can get a new token by running: npm run auth');
        }
    });

// Message deduplication cache with message IDs
const messageCache = new Map();
const MESSAGE_CACHE_TTL = 2000; // 2 seconds TTL
const COMMAND_COOLDOWN = 1000; // 1 second cooldown between same commands

function addToMessageCache(context, commandText) {
    const now = Date.now();
    const key = `${context.username}-${commandText}`;
    const messageId = context['message-id'] || context.id;
    
    // Check for duplicate message ID
    if (messageCache.has(messageId)) {
        return false;
    }
    
    // Check for command spam
    const lastExecution = messageCache.get(key);
    if (lastExecution && (now - lastExecution.timestamp) < COMMAND_COOLDOWN) {
        return false;
    }
    
    // Add to cache with both message ID and timestamp
    messageCache.set(messageId, { timestamp: now });
    messageCache.set(key, { timestamp: now });
    
    // Cleanup old entries
    setTimeout(() => {
        messageCache.delete(messageId);
        messageCache.delete(key);
    }, MESSAGE_CACHE_TTL);
    
    return true;
}

// Message handler for Twitch
async function onMessageHandler(target, context, msg, self) {
    // Log the message
    if (msg.startsWith('!') || msg.startsWith('?')) {
        logger.info(`[${target}] <${context.username}>: ${msg}`, {
            channel: target,
            chat: true,
            username: context.username
        });
        
        // Handle plugin command separately
        if (msg.toLowerCase().startsWith('!plugin ')) {
            try {
                const args = msg.split(' ');
                
                // Find all plugins that have a handlePluginCommand function
                const plugins = [...pluginManager.plugins.values()];
                
                for (const plugin of plugins) {
                    // Skip disabled plugins
                    if (!plugin.config || !plugin.config.enabled) {
                        continue;
                    }
                    
                    // Check if this plugin has a handlePluginCommand function
                    if (typeof plugin.handlePluginCommand === 'function') {
                        try {
                            // Try to handle the plugin command
                            const handled = await plugin.handlePluginCommand(client, target, context, args);
                            
                            // If the command was handled, we're done
                            if (handled) {
                                return;
                            }
                        } catch (error) {
                            logger.error(`Error in plugin ${plugin.name} handlePluginCommand: ${error.message}`);
                        }
                    }
                }
                
                // If we get here, no plugin handled the command
                await client.say(target, `@${context.username} Unknown plugin command. Use !plugin <plugin> <action> [options]`);
            } catch (error) {
                logger.error(`Error handling plugin command: ${error.message}`);
            }
            return;
        }
        
        // Handle commands through plugin manager
        try {
            await pluginManager.handleCommand(client, target, context, msg);
        } catch (error) {
            logger.error(`Error handling command: ${error.message}`);
        }
    }
    
    // Call all registered plugin message handlers
    for (const handler of botObject.messageHandlers) {
        try {
            await handler(target, context, msg, self);
        } catch (error) {
            logger.error(`Error in plugin message handler: ${error.message}`);
        }
    }
}

// Add a direct message handler to the client
client.on('message', async (channel, tags, message, self) => {
    // Skip messages from the bot itself
    if (self) return;
    
    // Process commands (support both ! and ? prefixes)
    if (message.startsWith('!') || message.startsWith('?')) {
        // Skip if the message is already in cache (duplicate)
        if (!addToMessageCache(tags, message)) {
            return;
        }
        
        // Use the plugin manager to handle the command
        await pluginManager.handleCommand(client, channel, tags, message);
    } else {
        // Not a command, process through plugins
        const messageObj = {
            channel,
            tags,
            message,
            self
        };
        
        // Process the message through plugins
        await pluginManager.processIncomingMessage(messageObj);
    }
});

// Add a chat command handler for the bot
client.on('message', (channel, tags, message, self) => {
    // Ignore messages from the bot itself
    if (self) return;
    
    // Check if the message is a reload command - strip all invisible characters first
    const cleanMessage = message.replace(/\p{C}/gu, '').trim();
    
    if (cleanMessage === '!reload') {
        // Check if the user is the broadcaster or a moderator
        const isMod = tags.mod || tags.badges?.broadcaster === '1';
        
        if (isMod) {
            logInfo(`Reload command received from ${tags.username}`);
            
            // Reload all plugins
            try {
                pluginManager.reloadAllPlugins();
                client.say(channel, `@${tags.username} Successfully reloaded all plugins.`);
            } catch (error) {
                logger.error('Error reloading plugins:', error);
                client.say(channel, `@${tags.username} Error reloading plugins: ${error.message}`);
            }
        }
    }
}); 